# -*- coding: utf-8 -*-
"""Run SSD in Google Colab - VOC2012

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l78eCfUt1yVBf0s6ilbhFFvS3GRJ5px8

# train / eval

download code / train set
"""

!git clone https://github.com/arvin-chou/models.git

!cd models/research/ && protoc object_detection/protos/*.proto --python_out=`pwd` && pwd \
export PYTHONPATH="${PYTHONPATH}:/content/models:/content/models/research/slim/" && \
python setup.py build && \
python setup.py install

!mkdir /content/models/research/object_detection/train
!mkdir /content/models/research/object_detection/eval
!mkdir /content/models/research/object_detection/ssd_model

!wget http://download.tensorflow.org/models/object_detection/ssd_mobilenet_v1_coco_11_06_2017.tar.gz \
 -O /content/models/research/object_detection/ssd_model/ssd_mobilenet_v1_coco_11_06_2017.tar.gz

!cd /content/models/research/object_detection/ssd_model && \
tar xf ssd_mobilenet_v1_coco_11_06_2017.tar.gz -C .

!cd /content/models/research/object_detection/ssd_model && \
wget http://cvlab.postech.ac.kr/~mooyeol/pascal_voc_2012/VOCtrainval_11-May-2012.tar && \
tar xf VOCtrainval_11-May-2012.tar -C .

!cd /content/models/research/object_detection/ssd_model && mv ssd_mobilenet_v1_coco_11_06_2017 ssd_mobilenet

"""transform tfrecord format"""

!cd /content/models/research/ && \
python ./object_detection/dataset_tools/create_pascal_tf_record.py --label_map_path=object_detection/data/pascal_label_map.pbtxt --data_dir=object_detection/ssd_model/VOCdevkit/ --year=VOC2012 --set=train --output_path=object_detection/ssd_model/pascal_train.record && \
python ./object_detection/dataset_tools/create_pascal_tf_record.py --label_map_path=object_detection/data/pascal_label_map.pbtxt --data_dir=object_detection/ssd_model/VOCdevkit/ --year=VOC2012 --set=val --output_path=object_detection/ssd_model/pascal_val.record

!cd /content/models/research/ && \
cp object_detection/data/pascal_label_map.pbtxt object_detection/ssd_model/ && \
cp object_detection/samples/configs/ssd_mobilenet_v1_pets.config object_detection/ssd_model/

"""setting tensorboard for debug"""

LOG_DIR = "train:/content/models/research/object_detection/train,eval:/content/models/research/object_detection/eval"

!export HOME=`pwd`
!wget https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-amd64.zip 
!unzip ngrok-stable-linux-amd64.zip -d .

!pkill -f "ngrok";
!pkill -f "tensorboard";


import os
  
get_ipython().system_raw(
    'tensorboard --logdir {} --host 0.0.0.0 --port 6006 &'
    .format(LOG_DIR))

get_ipython().system_raw('./ngrok http 6006 &')

!./ngrok http 6006

#!curl -s http://localhost:4040/api/tunnels
!curl -s http://localhost:4040/api/tunnels | python3 -c \
    "import sys, json; print(json.load(sys.stdin)['tunnels'][0]['public_url'])"

"""update config  && train"""

import os
file = open("/tmp/config", "w")
file.write("model {  \n\
  ssd {  \n\
    num_classes: 20  \n\
    box_coder {  \n\
      faster_rcnn_box_coder {  \n\
        y_scale: 10.0  \n\
        x_scale: 10.0  \n\
        height_scale: 5.0  \n\
        width_scale: 5.0  \n\
      }  \n\
    }  \n\
    matcher {  \n\
      argmax_matcher {  \n\
        matched_threshold: 0.5  \n\
        unmatched_threshold: 0.5  \n\
        ignore_thresholds: false  \n\
        negatives_lower_than_unmatched: true  \n\
        force_match_for_each_row: true  \n\
      }  \n\
    }  \n\
    similarity_calculator {  \n\
      iou_similarity {  \n\
      }  \n\
    }  \n\
    anchor_generator {  \n\
      ssd_anchor_generator {  \n\
        num_layers: 6  \n\
        min_scale: 0.2  \n\
        max_scale: 0.95  \n\
        aspect_ratios: 1.0  \n\
        aspect_ratios: 2.0  \n\
        aspect_ratios: 0.5  \n\
        aspect_ratios: 3.0  \n\
        aspect_ratios: 0.3333  \n\
      }  \n\
    }  \n\
    image_resizer {  \n\
      fixed_shape_resizer {  \n\
        height: 300  \n\
        width: 300  \n\
      }  \n\
    }  \n\
    box_predictor {  \n\
      convolutional_box_predictor {  \n\
        min_depth: 0  \n\
        max_depth: 0  \n\
        num_layers_before_predictor: 0  \n\
        use_dropout: false  \n\
        dropout_keep_probability: 0.8  \n\
        kernel_size: 1  \n\
        box_code_size: 4  \n\
        apply_sigmoid_to_scores: false  \n\
        conv_hyperparams {  \n\
          activation: RELU_6,  \n\
          regularizer {  \n\
            l2_regularizer {  \n\
              weight: 0.00004  \n\
            }  \n\
          }  \n\
          initializer {  \n\
            truncated_normal_initializer {  \n\
              stddev: 0.03  \n\
              mean: 0.0  \n\
            }  \n\
          }  \n\
          batch_norm {  \n\
            train: true,  \n\
            scale: true,  \n\
            center: true,  \n\
            decay: 0.9997,  \n\
            epsilon: 0.001,  \n\
          }  \n\
        }  \n\
      }  \n\
    }  \n\
    feature_extractor {  \n\
      type: 'ssd_mobilenet_v1'  \n\
      min_depth: 16  \n\
      depth_multiplier: 1.0  \n\
      conv_hyperparams {  \n\
        activation: RELU_6,  \n\
        regularizer {  \n\
          l2_regularizer {  \n\
            weight: 0.00004  \n\
          }  \n\
        }  \n\
        initializer {  \n\
          truncated_normal_initializer {  \n\
            stddev: 0.03  \n\
            mean: 0.0  \n\
          }  \n\
        }  \n\
        batch_norm {  \n\
          train: true,  \n\
          scale: true,  \n\
          center: true,  \n\
          decay: 0.9997,  \n\
          epsilon: 0.001,  \n\
        }  \n\
      }  \n\
    }  \n\
    loss {  \n\
      classification_loss {  \n\
        weighted_sigmoid {  \n\
        }  \n\
      }  \n\
      localization_loss {  \n\
        weighted_smooth_l1 {  \n\
        }  \n\
      }  \n\
      hard_example_miner {  \n\
        num_hard_examples: 3000  \n\
        iou_threshold: 0.99  \n\
        loss_type: CLASSIFICATION  \n\
        max_negatives_per_positive: 3  \n\
        min_negatives_per_image: 0  \n\
      }  \n\
      classification_weight: 1.0  \n\
      localization_weight: 1.0  \n\
    }  \n\
    normalize_loss_by_num_matches: true  \n\
    post_processing {  \n\
      batch_non_max_suppression {  \n\
        score_threshold: 1e-8  \n\
        iou_threshold: 0.6  \n\
        max_detections_per_class: 100  \n\
        max_total_detections: 100  \n\
      }  \n\
      score_converter: SIGMOID  \n\
    }  \n\
  }  \n\
}  \n\
  \n\
train_config: {  \n\
  batch_size: 24  \n\
  optimizer {  \n\
    rms_prop_optimizer: {  \n\
      learning_rate: {  \n\
        exponential_decay_learning_rate {  \n\
          initial_learning_rate: 0.0007  \n\
          decay_steps: 100000  \n\
          decay_factor: 0.1  \n\
        }  \n\
      }  \n\
      momentum_optimizer_value: 0.9  \n\
      decay: 0.9  \n\
      epsilon: 1.0  \n\
    }  \n\
    #momentum_optimizer: {  \n\
    #  learning_rate: {  \n\
    #    manual_step_learning_rate {  \n\
    #      initial_learning_rate: 0.0002  \n\
    #      schedule {  \n\
    #        step: 9000  \n\
    #        learning_rate: .00002  \n\
    #      }  \n\
    #      schedule {  \n\
    #        step: 12000  \n\
    #        learning_rate: .000002  \n\
    #      }  \n\
    #    }  \n\
    #  }  \n\
    #  momentum_optimizer_value: 0.9  \n\
    #}  \n\
  }  \n\
  fine_tune_checkpoint: \"/content/models/research/object_detection/ssd_model/ssd_mobilenet/model.ckpt\"  \n\
  from_detection_checkpoint: true  \n\
  load_all_detection_checkpoint_vars: true  \n\
  # Note: The below line limits the training process to 200K steps, which we  \n\
  # empirically found to be sufficient enough to train the pets dataset. This  \n\
  # effectively bypasses the learning rate schedule (the learning rate will  \n\
  # never decay). Remove the below line to train indefinitely.  \n\
  num_steps: 400000  \n\
  data_augmentation_options {  \n\
    random_horizontal_flip {  \n\
    }  \n\
  }  \n\
  data_augmentation_options {  \n\
    ssd_random_crop {  \n\
    }  \n\
  }  \n\
}  \n\
  \n\
train_input_reader: {  \n\
  tf_record_input_reader {  \n\
    input_path: \"/content/models/research/object_detection/ssd_model/pascal_train.record\"  \n\
  }  \n\
  label_map_path: \"/content/models/research/object_detection/ssd_model/pascal_label_map.pbtxt\"  \n\
}  \n\
  \n\
eval_config: {  \n\
  metrics_set: \"coco_detection_metrics\"  \n\
  num_examples: 1100  \n\
}  \n\
  \n\
eval_input_reader: {  \n\
  tf_record_input_reader {  \n\
    input_path: \"/content/models/research/object_detection/ssd_model/pascal_val.record\"  \n\
  }  \n\
  label_map_path: \"/content/models/research/object_detection/ssd_model/pascal_label_map.pbtxt\"  \n\
  shuffle: false  \n\
  num_readers: 1  \n\
}  \n\
")
file.close()

!cd /content/models/research/ && \
mv "/tmp/config" object_detection/ssd_model/ssd_mobilenet_v1_pets.config && \
cat object_detection/ssd_model/ssd_mobilenet_v1_pets.config | grep "exponential_decay_learning_rate" -A 20

"""run train / eval"""

import os
import time
import threading
from threading import Thread
import subprocess


OUTPUT_PATH = "/tmp/1"

#
# launch train
#
os.environ['PYTHONPATH'] += ":/content/models:/content/models/research/slim/"
os.chdir('/content/models/research/') 
get_ipython().system_raw( 'PYTHONPATH=${PYTHONPATH}:/content/models/research/slim/ /usr/bin/python3 object_detection/legacy/train.py --train_dir object_detection/train --pipeline_config_path object_detection/ssd_model/ssd_mobilenet_v1_pets.config > '+OUTPUT_PATH+' 2>&1 &' )


def call_script(args):
    subprocess.call(args)

#
# launch eval once train gen new one ckpt
#   
def monitor(i):
    tid = threading.get_ident()
    latest_ckpt = ""
    latest_log = ""
    while 1:
        content = ""
        
        if 1:#index 1= -1:
            p = subprocess.Popen("p=`ls object_detection/train/model.ckpt-* | sort -k 2 -t '-' -rn | grep 'meta' | head -n 1`;echo ${p%'.meta'}", 
                                  shell=True, stdout=subprocess.PIPE,
                                  stderr=subprocess.PIPE, stdin=subprocess.PIPE)
            stdout, stderr = p.communicate()
            if latest_ckpt != stdout:
                print ("launch eval", i, "time =>", stdout)
                i=i+1
                latest_ckpt = stdout
                !kill -9 $(ps -eo pid,command | grep python3 | grep "eval.py" | tr -s " " | cut -d ' ' -f 2 | head -n 1)
                os.chdir('/content/models/research/') 
                get_ipython().system_raw('/usr/bin/python3 ./object_detection/legacy/eval.py --eval_dir object_detection/eval --checkpoint_dir object_detection/train --pipeline_config_path "object_detection/ssd_model/ssd_mobilenet_v1_pets.config" &' )
            
            # monitor eval log
            p = subprocess.Popen("tail -n3 " + OUTPUT_PATH,
                                 shell=True, stdout=subprocess.PIPE,
                                 stderr=subprocess.PIPE, stdin=subprocess.PIPE)
            stdout, stderr = p.communicate()
            
            if 1:#latest_log != stdout:
                latest_log = stdout
                print ("out:", latest_log)
 
        time.sleep(10)    

i=0        
t3 = Thread(target=monitor, args=(i,))

t3.start()

t3.join()

"""#test"""

!cd /content/models/research/ && \
rm -r object_detection/ssd_model/model/saved_model ; \
[ -d "object_detection/ssd_model/model" ] || mkdir object_detection/ssd_model/model ; \
export PYTHONPATH="${PYTHONPATH}:/content/models:/content/models/research/slim/" && \
p=`ls object_detection/train/model.ckpt-* | sort -k 2 -t '-' -rn | grep 'meta' | head -n 1` && \
p=${p%".meta"} &&\
echo $p && \
python object_detection/export_inference_graph.py --input_type image_tensor \
--pipeline_config_path object_detection/ssd_model/ssd_mobilenet_v1_pets.config \
--trained_checkpoint_prefix $p \
--output_directory object_detection/ssd_model/model/

!cd /content/models/research/ && \
cp object_detection/ssd_model/pascal_label_map.pbtxt \
object_detection/ssd_model/pascal_label_map.txt 
#cat object_detection/ssd_model/pascal_label_map.txt

import os
file = open("/tmp/r", "w")
file.write("#import os  \n\
#os.getcwd()  \n\
#os.chdir('/content/models/research/')  \n\
R_F_NAME='/content/models/research/object_detection/ssd_model/img/test.png'  \n\
W_F_NAME='/content/models/research/object_detection/ssd_model/img/test_d.png'  \n\
  \n\
import cv2  \n\
import numpy as np  \n\
import tensorflow as tf  \n\
#from matplotlib import pyplot as plt  \n\
  \n\
import matplotlib  \n\
matplotlib.use('Agg')  \n\
import matplotlib.pyplot as plt  \n\
  \n\
from object_detection.utils import label_map_util  \n\
from object_detection.utils import visualization_utils as vis_util  \n\
  \n\
class TOD(object):  \n\
    def __init__(self):  \n\
        self.PATH_TO_CKPT = '/content/models/research/object_detection/ssd_model/model/frozen_inference_graph.pb'  \n\
        self.PATH_TO_LABELS = '/content/models/research/object_detection/ssd_model/pascal_label_map.txt'  \n\
        self.NUM_CLASSES = 20  \n\
        self.detection_graph = self._load_model()  \n\
        self.category_index = self._load_label_map()  \n\
  \n\
    def _load_model(self):  \n\
        detection_graph = tf.Graph()  \n\
        with detection_graph.as_default():  \n\
            od_graph_def = tf.GraphDef()  \n\
            with tf.gfile.GFile(self.PATH_TO_CKPT, 'rb') as fid:  \n\
                serialized_graph = fid.read()  \n\
                od_graph_def.ParseFromString(serialized_graph)  \n\
                tf.import_graph_def(od_graph_def, name='')  \n\
        return detection_graph  \n\
  \n\
    def _load_label_map(self):  \n\
        label_map = label_map_util.load_labelmap(self.PATH_TO_LABELS)  \n\
        categories = label_map_util.convert_label_map_to_categories(label_map,  \n\
                                                                    max_num_classes=self.NUM_CLASSES,  \n\
                                                                    use_display_name=True)  \n\
        category_index = label_map_util.create_category_index(categories)  \n\
        return category_index  \n\
  \n\
    def detect(self, image):  \n\
        with self.detection_graph.as_default():  \n\
            with tf.Session(graph=self.detection_graph) as sess:  \n\
                # Expand dimensions since the model expects images to have shape: [1, None, None, 3]  \n\
                image_np_expanded = np.expand_dims(image, axis=0)  \n\
                image_tensor = self.detection_graph.get_tensor_by_name('image_tensor:0')  \n\
                boxes = self.detection_graph.get_tensor_by_name('detection_boxes:0')  \n\
                scores = self.detection_graph.get_tensor_by_name('detection_scores:0')  \n\
                classes = self.detection_graph.get_tensor_by_name('detection_classes:0')  \n\
                num_detections = self.detection_graph.get_tensor_by_name('num_detections:0')  \n\
                # Actual detection.  \n\
                (boxes, scores, classes, num_detections) = sess.run(  \n\
                    [boxes, scores, classes, num_detections],  \n\
                    feed_dict={image_tensor: image_np_expanded})  \n\
                # Visualization of the results of a detection.  \n\
                vis_util.visualize_boxes_and_labels_on_image_array(  \n\
                    image,  \n\
                    np.squeeze(boxes),  \n\
                    np.squeeze(classes).astype(np.int32),  \n\
                    np.squeeze(scores),  \n\
                    self.category_index,  \n\
                    use_normalized_coordinates=True,  \n\
                    line_thickness=8)  \n\
  \n\
        # not use cv2.show in colab  \n\
        #cv2.namedWindow(\"detection\", cv2.WINDOW_NORMAL)  \n\
        #cv2.imshow(\"detection\", image)  \n\
        #cv2.waitKey(0)  \n\
        print(\"shape:\", image.shape)  \n\
        cv2.imwrite(W_F_NAME, image)  \n\
  \n\
if __name__ == '__main__':  \n\
    image = cv2.imread(R_F_NAME)  \n\
    detecotr = TOD()  \n\
    detecotr.detect(image)  \n\
           ")
file.close()

!cd /content/models/research/ && \
[ -d "object_detection/ssd_model/img" ] || mkdir object_detection/ssd_model/img && \
wget https://media.mnn.com/assets/images/2017/01/cow-in-pasture.jpg.838x0_q80.jpg -O object_detection/ssd_model/img/test.png && \
mv "/tmp/r" object_detection/r.py && \
python object_detection/r.py

"""draw"""

import cv2
import numpy as np
from matplotlib import pyplot as plt

img = cv2.imread("/content/models/research/object_detection/ssd_model/img/test_d.png")
img_cvt=cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
plt.imshow(img_cvt)
plt.show()